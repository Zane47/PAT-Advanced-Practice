## 最短路径
对给出的图G(V,E)和起点S, 终点T, 求从S到T的最短路径  
常用的算法有: `Dijkstra`, `Bellman-Ford`, `SPFA`, `Floyd`

### Dijkstra
单源最短路径  
* 基本思想  
对图G(V,E)设置集合S, 存放已被访问的定点, 然后每次从集合V-S中选择与起点s的最短距离最小的一个顶点(记为u), 访问并加入集合S. 之后, 令顶点u为中介点, 优化起点s与所有从u能到达的顶点v之间的最短距离. 这样的操作执行n次(n为顶点个数), 知道集合S已包含所有顶点  

* 注意点
    1. dijkstra只能应对所有边权非负数的情况, 如果边权出现负数, dijkstra可能出错, 这时候要用`SPFA算法`
    2. INF不能定义成`0x7fffffff`, 因为这样的两个数相加会超过int, 用`0x3fffffff`
    3. 邻接矩阵和邻接表两种图的表现方式不一样, 代码也不一样. `邻接矩阵`适用于顶点数不大的情况(<1000)

```
// 伪代码
// G为图, 一般设置成全局变量; 数组d为源点到各点的最短路径长度, s为起点
Dijkstra (G, d[], s) {
    初始化;
    for (循环n次) {
        u = 使d[u]最小的还未被访问的顶点的标号;
        记u被访问;
        for (从u出发能到达的所有顶点v) {
            if (v未被访问过 && 以u为中介点是s到v的距离比最短距离d[v]更优) {
                优化d[v];
            }
        }
    }
}
```
例子见: `AlexanderDemo.java`
推导的过程:

| currentNode(visited)| queue(从中取最小的)|
| ---- | ---- |
| null | s(0) |
| v0(0) | v1(1), v3(4), v4(4) |
| v1(1) | v3(3updated), v4(4) |
| v3(3) | v4(4), v2(5) |
| v4(4) | v2(5), v5(7) |
| v2(5) | v5(6updated) |
| v5(6) | null |



