## 最短路径
对给出的图G(V,E)和起点S, 终点T, 求从S到T的最短路径  
常用的算法有: `Dijkstra`, `Bellman-Ford`, `SPFA`, `Floyd`

### Dijkstra
单源最短路径  
#### 最短距离
* 基本思想  
对图G(V,E)设置集合S, 存放已被访问的定点, 然后每次从集合V-S中选择与起点s的最短距离最小的一个顶点(记为u), 访问并加入集合S. 之后, 令顶点u为中介点, 优化起点s与所有从u能到达的顶点v之间的最短距离. 这样的操作执行n次(n为顶点个数), 知道集合S已包含所有顶点  

* 注意点
    1. dijkstra只能应对所有边权非负数的情况, 如果边权出现负数, dijkstra可能出错, 这时候要用`SPFA算法`
    2. INF不能定义成`0x7fffffff`, 因为这样的两个数相加会超过int, 用`0x3fffffff`
    3. 邻接矩阵和邻接表两种图的表现方式不一样, 代码也不一样. `邻接矩阵`适用于顶点数不大的情况(<1000)

```
// 伪代码
// G为图, 一般设置成全局变量; 数组d为源点到各点的最短路径长度, s为起点
Dijkstra (G, d[], s) {
    初始化;
    for (循环n次) {
        u = 使d[u]最小的还未被访问的顶点的标号;
        记u被访问;
        for (从u出发能到达的所有顶点v) {
            if (v未被访问过 && 以u为中介点是s到v的距离比最短距离d[v]更优) {
                优化d[v];
            }
        }
    }
}
```
例子见: `AlexanderDemo.java`
推导的过程:

| currentNode(visited)| queue(从中取最小的)|
| ---- | ---- |
| null | s(0) |
| v0(0) | v1(1), v3(4), v4(4) |
| v1(1) | v3(3updated), v4(4) |
| v3(3) | v4(4), v2(5) |
| v4(4) | v2(5), v5(7) |
| v2(5) | v5(6updated) |
| v5(6) | null |

distance[]数组中就存储的是start结点到每一个结点的最短距离

#### 最短路径的求法
在伪代码中, 有这么一段:
```
if (v未被访问过 && 以u为中介点是s到v的距离比最短距离d[v]更优) {
                优化d[v];
}
```
这个地方的条件是: `以u为中介点可以使s到顶点v的最短距离d[v]更小`  
隐含了这么一层意思: 是d[v]变得更小的方案是让u作为s到v最短路径上v的前一个结点(s-> ... -> u -> v)  
所以, 我们将这个信息记录下来, 记录前驱结点`pre[]`, 令pre[v]表示从起点s到顶点v的最短路径上v的前一个顶点(即前驱结点)的编号, 这样子, 当伪代码条件成立的时候, 就可以把u赋给pre[v], 最终就可以把最短路径上每一个顶点的前驱结点记录下来.  
伪代码在*if*判断内添加一句:  
```
if (v未被访问过 && 以u为中介点是s到v的距离比最短距离d[v]更优) {
                优化d[v];
                令v的前驱为u
}
```
查看`AlexanderDemo.java`中的pre数据
![img.png](../img/graph/img.png)
如图这个简单的路径, 我们可以根据算法得到每个点的前驱
```
pre[4] = 3;
pre[3] = 2;
pre[2] = 1;
pre[1] = 1;
```
求v1到v4的路径, 那就是一个递归的逻辑, 从pre[4]知道前驱是3, 从pre[3]知道前驱是2, 从pre[2]中知道前驱是1, pre[1]是他本身, 递归结束  
所以递归代码:
```
// s为起点, v为当前访问的顶点编号(从终点开始递归)
void DFS(int s, int v) {
    // 当前到达起点s, 输出并返回
    if (v == s) {
        System.out.println(s);
        return;
    }
    // 递归访问v的前驱结点pre[v]
    DFS(s, pre[v]);
    // 最深层递归回来, 已经输出了起点, 接下来输出每一层的顶点v就可以了
    System.out.println(v);
}
```
